## Overview

There are two parties involved in an atomic swap, let’s call them Alice and Bob. Alice has some mwc that she wants to sell for Ether. Bob is interested in buying them. The first thing they need to do, is determine the amounts they want to exchange. They settle on swapping 50 mwc for 2 ETH. The broad steps are described as below:

- Lock up Alice's mwc in a 2-of-2 multi-signature output, where Alice and Bob each have a key. At the same time they are building this output, they need to build a refund transaction back to Alice, with a long lock time(**12hours**). We have to do this simultaneously, otherwise Bob has the ability to hold Alice's coins hostage. 

- Lock up Bob's Ether in a smart contract. This smart contract will pay out **only** to Alice, as soon as he provides a secret key `q`. This secret key is previously generated by Bob. The smart contract also has a refund option, but with a longer lock time(**24hours**) than the mwc output. 

- Finally Alice and Bob need to collaborate to let Bob transfer the mwc to an output owned by him. We have to set it up in a way that when Bob claims them, he reveals `x` to Alice, allowing her to submit it to the Ether smart contract.

Next， let’s explain each step more in depth!

## MWC side

An output in MWC is a Pedersen Commitment of the form `r*G+v*H`
, with `G` and `H` elliptic curve point generators. In this Commitment `r` is the secret key that has possession of amount `v`. 

Alice has to lock 50 mwc in a multi-signature output. This output looks like:
![](https://latex.codecogs.com/svg.latex?O_{multi}={x_{mA}G\+x_{mB}G\+vH) 
`v=50mwc` and ![](https://latex.codecogs.com/svg.latex?x_{mA}) and ![](https://latex.codecogs.com/svg.latex?x_{mB}) are the secret keys belonging to Alice and Bob, respectively. Since spending this output requires a signature for both secret keys, Alice and Bob have to work together to spend it.
To make sure their secret keys stay secret, they will only send the public keys ![](https://latex.codecogs.com/svg.latex?x_{mA}G) and ![](https://latex.codecogs.com/svg.latex?x_{mB}G) to each other.

### Time-locked refund

Before actually putting this output on chain, Alice wants to make sure she can get a refund if they don’t manage to finalize the swap. To that end, they build and sign a transaction where the multi-signature output is used as input and the coins (minus a transaction fee  ![](https://latex.codecogs.com/svg.latex?f_r) ) are returned to secret key ![](https://latex.codecogs.com/svg.latex?x_r) that only Alice knows:
<div style="align: center">
<table style="text-align: center; align: center:">
  <tr>
    <td >Inputs:</td>
    <td>Outputs:</td>
  </tr>
  <tr>
    <td ><img height="18px" class="center-block" src="https://latex.codecogs.com/svg.latex?O_{multi}"></td>
    <td><img height="18px" class="center-block" src="https://latex.codecogs.com/svg.latex?O_{refund}=x_rG+(v-f_r)H"></td>
  </tr>
</table> 
</div>

MWC uses [Schnorr signature](https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki)s to prove ownership of the in- and outputs. These signatures have the convenient property that they are linear, meaning that multiple parties can each independently produce a signature for their part, which can then be combined to obtain the final signature. In our case Alice produces a signature for ![](https://latex.codecogs.com/svg.latex?x_r-x_{mA}) and Bob for ![](https://latex.codecogs.com/svg.latex?-x_{mB}). The refund transaction has a lock height of 720 blocks in the future, which means it can only be included in a block roughly 12 hours later.  

### Multi-signature output

Now that Alice knows that she can get her grin back if Bob refuses to cooperate, they can safely create the multi-signature output. Alice has an unspent output of ![](https://latex.codecogs.com/svg.latex?v_i=100mwc) . Because she only needs 50 of those for the swap, the transaction also has to contain a refund output. The transaction has fee ![](https://latex.codecogs.com/svg.latex?f) and consists of the following elements:

<table frame=void rules=none cellspacing=0>
  <tr>
    <td >Inputs:</td>
    <td>Outputs:</td>
  </tr>
  <tr>
    <td ><img height="18px" class="center-block" src="https://latex.codecogs.com/svg.latex?O_{in}=x_iG+v_iH"></td>
    <td><img height="18px" class="center-block" src="https://latex.codecogs.com/svg.latex?O_{multi}"></td>
  </tr>
  <tr>
    <td ></td>
    <td><img height="18px" class="center-block" src="https://latex.codecogs.com/svg.latex?O_{change}=x_cG+(v_i-v-f)H"></td>
  </tr>
</table> 

Like before, Alice and Bob now generate partial signatures for their contributions, which are ![](https://latex.codecogs.com/svg.latex?x_{mA}+x_c-x_i) and ![](https://latex.codecogs.com/svg.latex?x_{mB}) respectively.

This transaction is missing one important component, namely the [rangeproof](https://eprint.iacr.org/2017/1066) on the multi-signature output. All outputs require a proof that shows that the amount doesn’t under or overflow. (It is outside of the scope of this doc) 

Now that the transaction is done, Alice submits it to the mwc network. 

## Ethereum side

Bob needs to deposit 2 ETH to MWC Smart Contract account which will be payed to Alice if she proves she knows $q$, or it gives a refund to Bob if sufficient time(24 hours) has passed. To achieve this, he sends $q*G$ to Alice and call $initiate$ function of swap contract which solidity code as below:

```javascript
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.0;

import "openzeppelin-solidity/contracts/cryptography/ECDSA.sol";

contract SwapContractAggregateSignature {

    struct Swap {
        uint refundTimeInBlocks;
        address initiator;
        address participant;
        uint256 value;
    }

    mapping(address => Swap) swaps;

    function initiate(uint refundTimeInBlocks, address addressFromSecret, address participant) public
        payable
    {
        require(swaps[addressFromSecret].refundTimeInBlocks == 0, "swap for this hash is already initiated");
        require(participant != address(0), "invalid participant address");
        require(block.number < refundTimeInBlocks, "refundTimeInBlocks has already come");

        swaps[addressFromSecret].refundTimeInBlocks = refundTimeInBlocks;
        swaps[addressFromSecret].participant = participant;
        swaps[addressFromSecret].initiator = msg.sender;
        swaps[addressFromSecret].value = msg.value;
    }

    function redeem(address addressFromSecret, bytes32 r, bytes32 s, uint8 v) public
    {
        require(msg.sender == swaps[addressFromSecret].participant, "invalid msg.sender");

        bytes32 hash = keccak256(abi.encodePacked(addressFromSecret, swaps[addressFromSecret].participant, swaps[addressFromSecret].initiator, swaps[addressFromSecret].refundTimeInBlocks));

        // If the signature is valid (and not malleable), return the signer address
        bytes32 ethSignedMessageHash = ECDSA.toEthSignedMessageHash(hash);
        address signer = ECDSA.recover(ethSignedMessageHash,  abi.encodePacked(r, s, v));

        require(signer == addressFromSecret, "invalid address");

        Swap memory tmp = swaps[addressFromSecret];
        delete swaps[addressFromSecret];

        (bool success, ) = payable(tmp.participant).call{value: tmp.value}("");
        require(success, "Transfer failed.");
    }

    function refund(address addressFromSecret) public
    {
        require(block.number >= swaps[addressFromSecret].refundTimeInBlocks, "refundTimeInBlocks has not come");
        require(msg.sender == swaps[addressFromSecret].initiator, "invalid msg.sender");

        Swap memory tmp = swaps[addressFromSecret];
        delete swaps[addressFromSecret];

        (bool success, ) = payable(tmp.initiator).call{value: tmp.value}("");
        require(success, "Transfer failed.");
    }

    function getSwapDetails(address addressFromSecret)
    public view returns (uint refundTimeInBlocks, address initiator, address participant, uint256 value)
    {
        refundTimeInBlocks = swaps[addressFromSecret].refundTimeInBlocks;
        initiator = swaps[addressFromSecret].initiator;
        participant = swaps[addressFromSecret].participant;
        value = swaps[addressFromSecret].value;
    }
}
```



This contract provides 4 functions:

- `initiate:`  deposit ETH to contract account (Bob will call this function to deposit 2 ETH which could only redeemed by Alice)
  - `refundTimeInBlocks:`  after this block,  initiator can refund his ETH
  - `addressFromSecret:`  trade index,it's a ethereum address generated by pub key $q*G$
  - `participant:`  the address of  who can get this 2 ETH(Alice's ETH address)
- `redeem:`   participant call this function to redeem ETH (Alice)
  - `addressFromSecret:`  trade index
  - `r:`  first 32 bytes of signature
  - `s:`  next 32 bytes of signature
  - `v:`  last byte of signature
- `refund:` initiator call this function to refund ETH(Bob)
  - `addressFromSecret:` trade index
- `getSwapDetails:`  check trade status (anyone)
  - `addressFromSecret:` addressFromSecret



**In this example:**

-  Bob  generate ethereum account base on secret `q`

-  Bob deposit 2 ETH to swap contract account with index `q*G`  （call *initiate* of swap contract）

## (Tongue) tying it all together：

Now that both sides have their funds locked up, we can execute the swap. Alice and Bob start building the transaction that will pay the mwc to Bob (using secret key ![](https://latex.codecogs.com/svg.latex?x_s) only known by Bob):


Bob can now build a partial signature (![](https://latex.codecogs.com/svg.latex?(s_B,%20k_B*G)) , using his secret keys:

![](https://latex.codecogs.com/svg.latex?s_B%20=%20k_B%20+%20e*(x_s%20-%20x_{mB}))

However, instead of sending this to Alice, he sends a [adaptor signature](https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/) ![](https://latex.codecogs.com/svg.latex?(s_B%27,%20k_B*G)), with ![](https://latex.codecogs.com/svg.latex?s_B%27%20=%20s_B%20+%20q). Alice can verify that the following relation holds:

![](https://latex.codecogs.com/svg.latex?s_B%27*G%20-%20q*G%20-%20e*(x_s*G%20-%20x_{mB}*G)%20=%20k_B*G)

In other words, she knows that when Bob finally submits the transaction using the total signature ![](https://latex.codecogs.com/svg.latex?(s_s,%20k_s*G)%20=%20(s_A+s_B,%20k_A*G+k_B*G)), she can perform a simple calculation to obtain $q$:

![](https://latex.codecogs.com/svg.latex?q%20=%20s_A%20+%20s_B%27%20-%20s_s)

Thus she is safe to send her partial signature ![](https://latex.codecogs.com/svg.latex?(s_A,%20k_A*G)) to Bob.
Bob combines the partial signatures and submits the final transaction to the network, thereby claiming the mwc. Alice calculates $q$ using the formula given above. She creates a signature and submits it to the smart contract and receives the Ether. This completes the swap!


## Sequence Diagram:
![mwc-eth-swap.png](https://i.postimg.cc/85CKFNZn/mwc-eth-swap.png)

The difference from mwc-bitcoin atomicswap is that the seller must redeem the ETH as soon as possible through his **ETH wallet** manually([MyCrypto](https://mycrypto.com/)) when the buyer redeemed the MWC. 

Ethereum uses an accounting system where values are debited from accounts and credited to another, it is different from Bitcoin's UTXO system. That means it's impossible to redeem ETH without account secret key. Managing eth account is beyond scope of this article, which will not be discussed here.
